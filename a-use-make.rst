如何使用 Make
=============

Make 工具用来自动构建或更新目标文件，而 Makefile 包含一组规则用来
描述怎样更新。一般情况下，如果 Make 不带命令行参数，它会执行默认的
Makefile 文件，并按照 Makefile 中的默认目标规则更新目标文件。但是
使用命令行参数，可以指定要执行哪个 Makefile，还可以通过指定目标只更
新其中的部分文件，另外还有其他更多选项来控制 Make 的行为。

Make 工具执行完毕后，有三种退出状态，这些值定义如下：

0
    返回 0 表示成功
2
    返回 2 表示遇到错误，make 会打印对应的错误信息
1
    返回 1 表示使用 -q 选项时存在需要更新的目标

指定 Makefile
--------------

使用 -f 或者 --file（或者 --makefile）选项可以指定 make 执行的 makefile,
可以多次使用该选项指定多个 makefile；如果没有使用该选项，默认的 makefile
名称是当前目录下的 GNUmakefile、makefile、Makefile，依次检查。也可以
没有 makefile 文件，这时 make 会查找内置的隐式规则来尝试构建目标。

指定执行目标
-------------

Makefile 文件包含多个规则，每个规则由规则目标、以及对应的前置条件和命令
组成。默认情况下，makefile 中的第一个规则中的目标，是 make 执行的默认目标，
如果在命令行不指定目标，make 默认执行该目标。这第一个目标是不以点字符开
头的目标，通常用来构建当前的程序或者所有的程序集合。如果第一个规则包含
多个目标，默认目标是是这些目标中的第一个。默认目标还可以通过 .DEFAULT_GOAL
变量在 makefile 中手动设定，这样默认目标不一定是第一个目标。

你可以在 make 命令行指定执行哪个目标，或者多个目标。如果指定了多个目标，
make 按顺序依次执行这些目标。任何 makefile 中的目标都可以传给 make，另外，
不在 makefile 中的但可以通过隐式规则自动构建的目标，也可以作为命令行目
标传给 make 执行。

但是以横杠字符开始的或者包含等号的名称不能作为 make 的命令行目标，因为以
横杠开始的名称被 make 解析为命令行选项，包含等号的名称被 make 解析为命令行
变量以及该变量的值，这些名称不会被解析成目标。

如果命令行指定了目标，make 会将目标列表设置到 MAKECMDGOALS 变量中，如果
没有指定命令行目标，这个变量为空。比如下面的例子，只有当没有指定 clean
目标时才包含 .d 后缀文件： ::

    sources = foo.c bar.c
    ifeq (,$(filter clean,$(MAKECMDGOALS)))
    include $(sources:.c=.d)
    endif

不对目标进行更新
----------------

执行 make 通常是为了构建或更新一个目标，但是指定一些选项可以让 make 不去更新
目标。这些选项如下：

-n --just-print --dry-run --recon "No-op"
    只打印需要执行的命令，而不真正执行，但是用 + 号开头的命令或者或者包含 $(MAKE)
    ${MAKE} 的命令仍然会执行。

-t --touch "Touch"
    不更新目标涉及的文件内容，仅仅更新文件的时间戳，该选项不会更新伪目标除非它
    的命令行以 + 开头或者包含 $(MAKE) 或者 ${MAKE}。

-q --question "Question"
    检查目标是否是最新的，不会执行命令，返回 0 表示是最新的，返回 1 表示需要更新，
    返回 2 表示执行 makefile 有错。

-W file --what-if-file --assume-new=file --new-file=file "What if“
    可以搭配 -n 或者 -q 来查看，如果指定的文件是最新的（用 -W 选项指定这些文件）
    会发生什么，make 会将记录当前的时间作为这些文件最后的修改时间。如果不使用
    -n 或者 -q 选项，make 会执行目标命令，相当于告诉 make 这些文件已经更新了，
    不需要再去执行这些文件的命令来更新这些文件。

不能在 make 的一次执行中，同时使用 -n -t -q 这三个选项中的多个，否则会报错。

避免某次修改的更新
------------------

比如你修改了一些文件但是修改是无关紧要的（像简单修改了一个头文件），你不想
其他所有对这些文件有依赖的文件都重新编译一遍，你可以使用 make -t 仅仅更新
所有需要更新的文件的时间戳，相当于忽略了这次修改，因为所有要更新的文件的时
间戳都是最新的了。

但是如果你在做这些修改之前，还修改了一些重要的文件，这些重要文件的修改确实
是需要更新的。你可以使用 -o 选项，把这次修改的无关紧要的文件设置成老文件，
就像这些无关紧要的文件没有被修改一样，先把那些重要的修改进行更新。例如：
make -o header_file1 -o header_file2。

当重要文件的修改更新后，再执行 make -t 来忽略无关紧要的修改，比如上面两个头文
的修改。下次如果想要所有文件都真正是最新的，可以 touch 这些上次修改过的头文件，
然后正常编译，或者清除所有文件完整的重新编译。

用于测试的选项
--------------

正常当 make 遇到错误会立即停止执行，并返回非零的错误代码。但如果你想让 make 在
返回之前尽可能多的执行，以便发现尽量多的错误，可以使用 -t 或者 --keep-going
选项。

使用该选项，当 make 执行一个目标失败时，它还会继续执行该目标所在前置条件列表
的其他前置条件，并且发现一个不知道怎么构建的目标或前置条件之后，make 不会像
正常那样报致命错误，还会继续尝试其执行他的目标。

执行 make 通常的目的是更新目标文件，一旦 make 发现不可以做到时就会立即上报错误。
而 -k 选项则表明执行 make 的目的是尽可能多的发现上次修改中的错误，以便可以在下次
执行之前一次性加以更正。这也是为什么 Emacs 在 M-x compile 命令中默认使用 -t 选项
的原因。

临时文件目录
------------

一些情况下，make 需要创建临时文件，这些临时文件一般不应该扰乱 make 当前的执行，
包括递归调用的子 make 的执行。

如果 MAKE_TMPDIR 这个环境变量进行了设置，make 创建的所有临时文件都会被放到这个
目录下。如果这个环境变量没有设置，那么当前系统标准的临时文件夹会被使用，例如
POSIX 系统上 TMPDIR 环境变量代表的临时文件夹或者其他系统默认的临时文件夹比如
/tmp。而 Windows 系统，会依次查看 TMP TEMP TMPDIR，最后系统的默认临时文件夹。
这些变量不能在 makefile 中设定，GNU make 必须在读取 makefile 之前读取到这个目录。

注意，这个目录必须是已经存在的，make 不会自动创建这个目录，不管不存在执行 make
会失败。

命令行选项汇总
--------------

-b -m
    会被忽略，仅为与其他版本的 make 兼容

-B --always-make
    认为所有的目标都需要重新更新，不考虑目标的前置条件状态。为了避免无限递归，
    当 MAKE_RESTARTS 大于 0，并且 make 在判断 makefile 是否需要更新时，会关闭
    该选项。

-C dir --directory=dir
    先进入指定的目录再读取 makefile 文件，如果有多个该选项，相当于进到将这些目录
    进行拼接后形成的目录。

-d --trace --debug[=options] 
    正常执行的同时打印 debug 信息，选项 -d 相当于选项 --debug=a；选项 --trace
    等价于 --debug=print,why；选项 --debug 如果不指定参数，相当于打印基本信息
    （basic），可以指定多个值，值之间用逗号或者空格分隔：

    * a (all) - 所有信息
    * b (basic) - 基本信息，需要更新的目标以及是否构建成功
    * v (verbose) - 在基本信息的基础上，还包括哪些 makefile 文件被解析了，那些前置条件不需要重建，等等
    * i (implicit) - 在基本信息的基础上，打印每个目标搜寻的隐式规则
    * j (jobs) - 执行子命令时打印详细的调用信息
    * m (makefile) - 在基本信息的基础上，打印构建 makefile 文件时的信息
    * p (print) - 打印要执行的命令，即使设置为 .SLIENT 或者 @ 的命令也会被打印，并且打印命令所在的文件和行数
    * w (why) - 打印目标为什么需要更新，是那些前置条件导致的更新
    * n (none) - 关掉所有的打印，但是上面的值出现在n之后，对应的值还是会生效

-e --environment-overrides
    使得环境变量的优先级比 makefile 中定义的变量的优先级更高，makefile 中的变量值
    会被环境变量的值覆盖。

-E string --eval=string
    命令行版本的 eval 函数调用，这个调用会在读取任何 makefile 之前执行。

-f file --file=file --makefile=file
    指定要执行的 makefile 文件

-h --help
    打印 make 支持的命令行选项

-i --ignore-errors
    忽略所有命令执行的错误

-I dir --include-dir=dir
    指定包含 makefile 文件的搜索目录，如果指定了多个目录，会按顺序依次搜索，
    如果指定的值是一个横杠字符，表示丢弃前面所有已经设置的目录，并且默认
    的搜索目录也会被去掉。可以查看 .INCLUDE_DIRS 变量检查当前的搜索目录列表。

-j [jobs] --jobs[=jobs]
    设置同时可以执行的命令条数，如果不带参数，make 会同时执行尽量多的操作命令。
    如果设置了多个选项，最后一个选项生效。该选项在 MS-DOS 系统上会被忽略。

--jobserver-style=[style]
    选择 jobserver 的执行方式，只有当并行执行开启时才生效。在 POSIX 系统上，可以
    是 fifo（默认）或者 pipe。在 Windows 系统上可以接受的方式是 sem（默认）。当
    使用老版本 GNU make 或者特殊的程序需要指定的方式时，可以使用这个选项。

-k --keep-going
    发生错误后尽可能的继续执行

-l [load] --load-average[=load] --max-load[=load]
    当有操作命令在执行时，如果系统负载超过设定的负载 load（浮点数），不能启动
    新的操作命令同时执行。如果不指定参数，相当于取消掉对负载设定的限制。

-L --check-symlink-times
    设置对于符号链接文件，不仅检查自己的时间戳并且检查指向的文件的时间戳，看哪个
    时间戳更新就使用哪个。

-n --just-print --dry-run --recon
    只打印需要执行的操作命令，不执行

-o file --old-file=file --assume-old=file
    将对应的文件设置成旧文件，相当于忽略对这些文件当前的修改

-O[type] --output-sync[=type]
    仅当并行执行开启时才生效，它指定并行执行时 make 输出打印的颗粒度。如果不带参数
    或者带的参数是 target，那么 make 会缓存整个目标构建时的打印然后一次性输出。如果
    是 line 按每个命令行输出，recurse 整个递归调用的 make 进程一次输出，none 不对
    打印进行输出同步。

-p --print-data-base
    打印 make 读取 makefile 之后的数据库，即定义的规则和变量值，然后正常执行 make。
    这个选项还打印 make 的版本信息，如果只打印不去更新目标文件，可以使用 make -qp。
    如果只打印 make 预定义的规则和变量，可以使用 make -p -f /dev/null。

-q --question
    不执行造作命令也不打印目标构建过程的信息，仅仅返回目标是否已经是最新的，返回
    0 表示是最新的，返回 1 不是，返回 2 表示出错。

-r --no-builtin-rules
    清除内置的影视规则和后缀名列表，但是你可以定义自己的隐式规则，也可以添加自己的
    后缀类型和对应的后缀规则。

-R --no-builtin-variables
    清除所有 make 预定义的与隐式规则相关的变量。同时会清除所有内置的隐式规则。

-s --silent --quiet
    不在命令执行之前打印该命令

-S --no-keep-going --stop
    取消掉 -k 选项，因为当前的 make 可能继承了环境中定义的或者顶层 make 中定义的 -k
    选项，选项通过 MAKEFLAGS 变量进行传递。

--shuffle[=mode]
    并行执行时，目标执行的顺序会变得不那么确定，如果一个前置条件定义得不完整，可能
    造成不能确定复现的难以跟踪的问题。该选项可以开启前置条件关系的混淆测试，它强制
    make 维持 target 和前置条件的关系，但是按指定的顺序执行前置条件列表中的目标。
    这个在定义了 .NOTPARALLEL 伪目标的 makefile 文件，和包含 .WAIT 的前置条件列表
    中不生效。该选项定义了以下的值：

    * randomm - 如果不指定参数，默认是这个值。选择一个随机种子进行打乱，这个种子会传递给子 make
    * reverse - 反转前置条件列表的顺序
    * seed - 使用 random 打乱顺序，但是使用指定的 seed（整数值）
    * none - 清掉前面这个选项的值

-t --touch
    不执行操作命令，只更新对应文件的时间戳

-v --version
    打印版本信息

-w --print-directory --no-print-directory
    打印目录进出信息，或清除前面定义的 —w 选项

-W file --what-if=file --new-file=file --assume-new=file
    假定对应的文件是最新的，make 在执行时不需要再去执行对应的命令更新这些文件

\--warn-undefined-variables
    当引用的变量未定义时给出提示，这在 debug 时有用
